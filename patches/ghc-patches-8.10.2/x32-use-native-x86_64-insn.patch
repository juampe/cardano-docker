Description: Use native x86_64 instructions on x32
 This patch enables a few native 64-bit integer instructions
 on x32 which are available on this architecture despite using
 32-bit pointers. These instructions are present on x86_64 but
 not on x86 and ghc checks the size of (void *) to determine
 that. This method fails on x32 since despite using 32-bit
 pointers and hence sizeof(void *) == 4, it still uses the
 full x86_64 instruction set and software-emulated variants
 of the aforementioned 64-bit integer instructions are
 therefore not present in the toolchain which will make ghc
 fail to build on x32.
 See: https://ghc.haskell.org/trac/ghc/ticket/11571
 .

Description: Revert patch [linker/rtsSymbols] More linker symbols
regression https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3434 patch causes 
https://gitlab.haskell.org/ghc/ghc/-/issues/18442 error: undefined reference to '__stack_chk_guard'

Index: ghc-8.10.2/rts/RtsSymbols.c
===================================================================
diff --git a/rts/RtsSymbols.c b/rts/RtsSymbols.c
index d10a6900db..72bb773899 100644
--- a/rts/RtsSymbols.c
+++ b/rts/RtsSymbols.c
@@ -1140,7 +1140,7 @@

 #if defined(__GNUC__) && SIZEOF_VOID_P <= 4 && defined(arm_HOST_OS)
 #define RTS_LIBGCC_SYMBOLS RTS_LIBGCC_SYMBOLS_32 RTS_LIBGCC_SYMBOLS_aarch32
-#elif defined(__GNUC__) && SIZEOF_VOID_P <= 4 && !defined(_ABIN32)
+#elif defined(__GNUC__) && SIZEOF_VOID_P <= 4 && !defined(_ABIN32) && !defined(_ABIN32) && !(defined(__x86_64__) && defined(__ILP32__))
 #define RTS_LIBGCC_SYMBOLS RTS_LIBGCC_SYMBOLS_32
 #elif defined(__GNUC__) && SIZEOF_VOID_P == 8 && defined(aarch64_HOST_OS)
 #define RTS_LIBGCC_SYMBOLS RTS_LIBGCC_SYMBOLS_64 RTS_LIBGCC_SYMBOLS_aarch64
@@ -1264,14 +1264,11 @@ RtsSymbolVal rtsSyms[] = {
       RTS_LIBGCC_SYMBOLS
       RTS_LIBFFI_SYMBOLS
       SymI_HasDataProto(nonmoving_write_barrier_enabled)
-      RTS_SSP_SYMBOLS
-      RTS_LINKER_SYMBOLS
 #if defined(darwin_HOST_OS) && defined(i386_HOST_ARCH)
       // dyld stub code contains references to this,
       // but it should never be called because we treat
       // lazy pointers as nonlazy.
       { "dyld_stub_binding_helper", (void*)0xDEADBEEF, false },
 #endif
-      { "_DYNAMIC", (void*)(&RTS_DYNAMIC), false },
       { 0, 0, false } /* sentinel */
 };
